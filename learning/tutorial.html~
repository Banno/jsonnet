---
layout: default
---

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h1 id="tutorial">Tutorial</h1>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Let's explore the various features in Jsonnet, and mix some cocktails.  If you're looking at
        Jsonnet for the first time, this is the right place to be.  For a detailed systematic
        overview, check out the language <a href="/ref/language.html">reference</a>.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="syntax">Syntax</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Any <a href="https://json.org">JSON</a> document is a valid Jsonnet program, so we'll focus
        on what Jsonnet adds to JSON.  Let's start with an example that does not involve any
        computation but uses new syntax.
      </p>
      <ul>
        <li>Fields that happen to be valid identifiers have no quotes</li>
        <li><i>Trailing</i> commas at the end of arrays / objects</li>
        <li>Comments</li>
        <li>
          String literals use <code>"</code> or <code>'</code>.  The single quote is easier on the
          eyes but either can be used to avoid escaping the other, e.g. <code>"Farmer's Gin"</code>
          instead of <code>'Farmer\'s Gin'</code>.
        </li>
        <li>
          Text blocks <code>|||</code> allow verbatim text across multiple lines.
        </li>
        <li>
          Verbatim strings <code>@'foo'</code> and <code>@"foo"</code> are for single lines.
        </li>
      </ul>
      <p>
        Play with the code, e.g., modifying the strings / quantities.  Try adding a "Dry Manhattan"
        which uses dry red vermouth and is garnished with a lemon slice.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="syntax" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="variables">Variables</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Variables are the simplest way to avoid duplication.
      </p>
      <ul>
        <li>The <code>local</code> keyword defines a variable.</li>
        <li>Variables defined next to fields end with a comma (<code>,</code>).</li>
        <li>All other cases end with a semicolon (<code>;</code>).</li>
      </ul>
      <p>
        Try factoring out <code>"Simple Syrup"</code> to the top level or to the same level as
        the <code>pour</code> variable.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="variables" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="references">References</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Another way to avoid duplication is to refer to another part of the structure.
      </p>
      <ul>
        <li><code>self</code> refers to the current object.</li>
        <li><code>$</code> refers to the outer-most object.</li>
        <li><code>['foo']</code> looks up a field.</li>
        <li><code>.f</code> can be used if the field name is an identifier.</li>
        <li><code>[10]</code> looks up an array element.</li>
        <li>Arbitrarily long paths are allowed.</li>
        <li>Array slices like <code>arr[10:20:2]</code> are allowed, like in Python.</li>
        <li>Strings can be looked up / sliced too, by unicode codepoint.</li>
      </ul>
      <p>
      Another name for a Tom Collins is a Gin Fizz.  Try adding an alias for that.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="references" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        In order to refer to objects between the current and outer-most object, we use a variable to
        create a name for that level:
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="inner-reference" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="arithmetic">Arithmetic</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Arithmetic includes numeric operations like multiplication but also various operations on
        other types.
      </p>
      <ul>
        <li>Use floating point arithmetic, bitwise ops, boolean logic.</li>
        <li>
          Strings may be concatenated with <code>+</code>, which implicitly converts
          one operand to string if needed.
        </li>
        <li>Two strings can be compared with <code>&lt;</code> (unicode codepoint order).</li>
        <li>
          Objects may be combined with <code>+</code> where the right-hand side wins field
          conflicts.
        </li>
        <li>Test if a field is in an object with <code>in</code>.</li>
        <li><code>==</code> is deep value equality.</li>
        <li>Python-compatible string formatting is available via <code>%</code>.  When combined with
        <code>|||</code> this can be used for templating text files.</li>
      </ul>
      <p>Try dividing by zero to see what happens.</p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="arith" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="functions">Functions</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Like Python, functions have positional parameters, named parameters, and default arguments.
        Closures are also supported.  The examples below should demonstrate the syntax.  Many
        functions are already defined in the <a href=/ref/std.html>standard library</a>.
      </p>
      <p>
        Try writing a function <code>is_even</code> that uses the modulo operator <code>%</code> and
        returns either true or false.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="functions" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="conditionals">Conditionals</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Conditional expressions look like <code>if b then e else e</code>. The
        <code>else</code> branch is optional and defaults to <code>null</code>.
      </p>
      <p>
        Try adding the missing Large Virgin Mojito:
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="conditionals" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="computed_field_names">Computed Field Names</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Jsonnet objects can be used like a <code>std::map</code> or similar datastructures from
        regular languages.
      </p>
      <ul>
        <li>Recall that a field lookup can be computed with <code>obj[e]</code></li>
        <li>The assignment equivalent is <code>{[e]: ...}</code></li>
        <li>
          <code>self</code> or object locals cannot be accessed when field names are being computed,
          since the object is not yet constructed.
        </li>
        <li>
          If a field name evaluates to <code>null</code> during object construction, the field is
          omitted.  This works nicely with the default false branch of a conditional (see below).
        </li>
      </ul>
      <p>Try adding <code>[self.f]: 'f'</code> to see what happens.</p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="computed-fields" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="comprehension">Array and Object Comprehension</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        What if you want to make an array or object and you don't know how many elements / fields
        they will have at run-time?  Jsonnet has Python-style array and object comprehension
        constructs to allow this.
      </p>
      <ul>
        <li>Any nesting of <code>for</code> and <code>if</code> can be used.</li>
        <li>The nest behaves like a loop nest, although the body is written first.</li>
      </ul>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="comprehensions" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Below, a less contrived example.  The first cocktail has equal parts of three ingredients.
        The second iterates over an array of records - name prefix and fruit juice.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="cocktail-comprehensions" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="modularity">Modularity and Encapsulation</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        As the amount of JSON grows, its size makes it harder to manage.  Jsonnet has various
        constructs to help.  A file can be broken into parts, as one Jsonnet file can import other
        Jsonnet files (and therefore other JSON files), or a whole text file can be imported as a
        string value.  Values can be held in local variables and fields, which are only visible
        within their scopes.  Functions can be defined to factor out common descriptions, and error
        statements can be used to validate inputs.  Jsonnet provides a standard library that is
        implicitly imported and contains useful functions for data manipulation, among other
        things.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h3 id="imports">Imports</h3>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The first example below factors out some cocktails into a separate file.  This may be useful
        to allow concurrent modifications by different mixologists.
      </p>
      <p>
        The <code>import</code> construct yields the content of the <tt>martinis.libsonnet</tt> file
        evaluated as a Jsonnet object. The <code>+</code> operator is object concatenation, which
        combines two objects to form a single object.  Note that the Cosmopolitan field is defined
        in both files, so the one on the right hand side is used.  This means that
        <tt>bar_menu.jsonnet</tt> has overridden the recipe from <tt>martinis.libsonnet</tt> with a
        different recipe (one that uses Cointreau instead of Triple Sec, among other changes).
      </p>
      <p>
        The <code>importstr</code> construct yields a string with the content of the
        <tt>bar_menu.6.manhattan_garnish.txt</tt> file without any processing beyond UTF-8 decoding.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="bar-menu-6-input">
      <div class="tab-header">
      </div>
      <textarea id=bar-menu-6-jsonnet>
{% include examples/bar-menu-6.jsonnet %}
      </textarea>
      <textarea id=martinis-libsonnet>
{% include examples/martinis.libsonnet %}
      </textarea>
      <textarea id=garnish-txt>
{% include examples/garnish.txt %}
      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="bar-menu-6-output">
      <div class="tab-header">
        <div class=selected onclick="tab_output_click(this, 'bar-menu-6-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="bar-menu-6-json-output">
{% include examples/bar-menu-6.jsonnet.golden %}
      </textarea>
    </div>
    <script>
      demo(
        'bar-menu-6-input',
        {
          'bar-menu-6.jsonnet': 'bar-menu-6-jsonnet',
          'martinis.libsonnet': 'martinis-libsonnet',
          'garnish.txt': 'garnish-txt',
        },
        'bar-menu-6.jsonnet',
        'bar-menu-6-output',
        false,
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        By convention, Jsonnet code that is intended only for importing has a <tt>.libsonnet</tt>
        extension.  This is not enforced, it simply allows you to distinguish between the two kinds
        of files when listing a directory.  In fact, for files that are both imported and executed
        directly, it is better to keep the <tt>.jsonnet</tt> suffix.  A commonly occurring example
        of that is test cases.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h3 id="functions">Functions</h3>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The next example demonstrates functions (actually, closures).  We have a separate file
        holding a utility function to help with defining cocktails made from equal parts, such as
        the Bee's Knees and the Negroni.  The utility function also checks the number of ingredients
        and raises an error if the list is empty.  This avoids the low level divide by zero error
        that would be raised when calculating the quantity, thus avoiding the exposure of
        implementation details.
      </p>
      <p>
        There is also an identity function defined.  This is there to demonstrate that function
        definitions are really just syntax sugar for closures that are assigned to a field.
      </p>
      <p>
        Finally, you may have noticed that two colons are used instead of one.  This marks the field
        as being <dfn>hidden</dfn>, i.e. it will not appear in the JSON output.  The field can still
        be accessed by Jsonnet code, so it is not like the private/protected modifier that some
        languages have.  Hidden fields are convenient for functions, which cannot be manifested in
        the JSON output.  It has other uses too, as we will see in the later section on object
        orientation.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h3 id="locals">Local Variables</h3>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Like most languages, Jsonnet has <dfn>variables</dfn>, which can be used to factor out
        expressions.  They are referenced using standard static <a
        href="http://en.wikipedia.org/wiki/Scope_(computer_science)">scoping</a> rules.  In the
        following case, the imported object is stored in the variable, which is later referenced to
        access the <code>equal_parts</code> function.  It is also possible to store the import in a
        field of the root object, and access it with <code>$</code>.  In that case, it should be a
        hidden field (using the :: syntax) in order to avoid appearing in the output of
        <code>bar_menu.7.jsonnet</code>.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="bar-menu-7-input">
      <div class="tab-header">
      </div>
      <textarea id=bar-menu-7-jsonnet>
{% include examples/bar-menu-7.jsonnet %}
      </textarea>
      <textarea id=bar-menu-utils-libsonnet>
{% include examples/bar-menu-utils.libsonnet %}
      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="bar-menu-7-output">
      <div class="tab-header">
        <div class=selected onclick="tab_output_click(this, 'bar-menu-7-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-json" id="bar-menu-7-json-output">
{% include examples/bar-menu-7.jsonnet.golden %}
      </textarea>
    </div>
    <script>
      demo(
        'bar-menu-7-input',
        {
          'bar-menu-7.libsonnet': 'bar-menu-7-libsonnet',
        },
        'bar-menu-7.jsonnet',
        'bar-menu-7-output',
        false,
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Variables can appear anywhere within the program structure; in particular, they can appear
        inside an object (i.e.  alongside field declarations).  The <code>my_gin</code> variable is
        an example of using <code>local</code> inside an object.  In this situation they are
        analogous to "private" fields, as defined in other languages.  This is because the
        initializer of the variable (in this case the string <code>"Farmer's Gin"</code>, but in
        general an arbitrary expression) can access <code>self</code> and <code>super</code>, just
        like a field.  However, unlike with fields, it is not possible for anyone to access the
        variable except by name, within the object's scope.
      </p>
      <p>
        In both cases, there is a separator that indicates the end of the variable initializer.  If
        the variable is defined alongside object fields, the separator is a comma in order to match
        the regular field separator.  Otherwise the separator is a semicolon.
      </p>
      <p>
        The variable can be referenced within its own initializer, which is essential for writing
        recursive functions.
      </p>
      <p>
        Variables offer a more general alternative to the <code>$</code> operator, by allowing the
        stashing of the <code>self</code> value.  This can be useful to "name" an object in the
        middle of the tree, because the path from <code>$</code> might be long.  <code>$</code> is
        actually equivalent to a stashing <code>self</code> in a variable at the outermost object.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="bar-menu-8" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h3 id="stack_traces">Stack Traces</h3>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Jsonnet provides stack traces when an error is raised.  Here is an example, where we provide
        an empty list of ingredients to the <code>equal_parts</code> function.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="inverse hgroup">
  <div class=hgroup-inline>
    <div class="tab-window-input" id="no-ingredients-input">
      <div class="tab-header">
      </div>
      <textarea id=no-ingredients-jsonnet>
{% include examples/no-ingredients.jsonnet %}
      </textarea>
      <textarea id=bar-menu-utils-libsonnet>
{% include examples/bar-menu-utils.libsonnet %}
      </textarea>
    </div>
    <div class="bigarrow">➡</div>
    <div class="tab-window-output" id="no-ingredients-output">
      <div class="tab-header">
        <div class=selected onclick="tab_click(this, 'no-ingredients-json-output')">output.json</div>
      </div>
      <textarea readonly class="selected code-error" id="no-ingredients-json-output">
{% include examples/no-ingredients.jsonnet.error %}
      </textarea>
    </div>
    <script>
      demo(
        'no-ingredients-input',
        {
          'no-ingredients.jsonnet': 'no-ingredients-jsonnet',
          'bar-menu-utils.libsonnet': 'bar-menu-utils-libsonnet',
        },
        'no-ingredients.jsonnet',
        'no-ingredients-output',
        false,
      );
    </script>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="oo">Object-Orientation</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        Finally, we see how Jsonnet provides the abstraction mechanisms of object oriented
        programming, to allow the writing of base templates that can be extended for a variety of
        purposes.
      </p>
      <p>
        The object concatenation operator <code>+</code> can be used to override fields from one
        object with another.  This is similar to the concept of inheritance in object-oriented
        languages such as C++ and Java.  It can be used to derive variants from a single template.
        In the following example, a Whiskey Sour with egg white is derived from the original Whiskey
        Sour.
      </p>
      <p>
        The <code>super</code> keyword, as in Java, allows access to the object being derived from,
        i.e.  the object on the left hand side of the <code>+</code> operator.  In this case, it is
        being used to fetch the original ingredients of the whiskey sour, so that a 4th ingredient
        can be added.  Removing the <code>super.ingredients + </code> would result in a cocktail
        containing only egg white.
      
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="bar-menu-9" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The key to making Jsonnet object-oriented is that the <code>self</code> keyword be "late
        bound".  This is illustrated in the next example, where an alternative menu is derived from
        the above.  It takes the original menu, and replaces the cocktails object with a new object
        that is in turn based on the original menu's cocktail object.  But this new cocktail object
        overrides the Whiskey sour, changing Bourbon to Scotch (among other things).  The effect of
        this is not just to replace the whiskey sour but also to change how the <code>self</code>
        keyword behaves in the original menu.  This results in the egg variant now being derived
        from the new whiskey, because that is now what <code>self["Whiskey Sour"]</code> resolves
        to.  This is classic object-orientation in action, and it is very powerful.
      </p>
      <p>
        Note also that this example makes use of two syntax sugars (shorthands).  The first is that
        the object concatenation <code>+</code> was omitted.  This is allowed when it is followed by
        an opening brace, so in fact this same simplification could have also been made in all of
        the previous examples utilizing the object concatenation operator <code>+</code>.  The
        second syntax sugar is the <code>f +: e</code> operator, which is a little like the +=
        operator from other languages.  Its behavior is the same as saying <code>f: if "f" in super
        then super.f + e else e</code>.  This works not just for <code>+</code> when used for
        inheritance, but also for string concatenation, list concatenation, and arithmetic addition,
        so it could also have been used in the previous example to add the egg white.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="bar-menu-10" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        The hidden status (i.e. <code>::</code>) of a field is preserved over inheritance.  If you
        override a field using the <code>:</code> syntax, but the original field was defined with
        <code>::</code>, then the new object's field will also be hidden.  To make the field visible
        use three colons (<code>:::</code>).  This is illustrated below.  The values are all
        inherited without change, but the use of colons changes the visibility of fields in the case
        of <code>x</code> and <code>w</code>.  The <code>x</code> field is hidden by
        <code>foo</code> because of the double colons.  The <code>y</code> field remains hidden in
        <code>foo</code> because the single colon inherits the hidden status from <code>Base</code>.
        The triple colon in <code>z</code> however overrides the hidden status from
        <code>Base</code> to make the field visible in <code>foo</code>.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="hidden-fields" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <h2 id="parameterize-entire-config">Parameterize Entire Config</h2>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        TODO: Use this example for std.extVar and TLA.
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>

{% include demo.inc name="bar-menu-11" %}

<div class="hgroup">
  <div class="hgroup-inline">
    <div class="panel">
      <p>
        TODO: tla/extvar, recursive functions (tailstrict) more detail on OO TODO: errors, asserts,
        object asserts, debug via error
      </p>
    </div>
    <div style="clear: both"></div>
  </div>
</div>
